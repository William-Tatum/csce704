Title: CWE-14: Compiler Removal of Code to Clear Buffers
Description: Sensitive memory is cleared according to the source code, but compiler optimizations leave the memory untouched when it is not read from again, aka "dead store removal."
Extended Description: This compiler optimization error occurs when:Secret data are stored in memory.The secret data are scrubbed from memory by overwriting its contents.The source code is compiled using an optimizing compiler, which identifies and removes the function that overwrites the contents as a dead store because the memory is not used subsequently.

--------------------------------------------------------------------------------

Title: CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer
Description: The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.
Extended Description: Certain languages allow direct addressing of memory locations and do not automatically ensure that these locations are valid for the memory buffer that is being referenced. This can cause read or write operations to be performed on memory locations that may be associated with other variables, data structures, or internal program data.

--------------------------------------------------------------------------------

Title: CWE-120: Buffer Copy without Checking Size of Input
Description: The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.
Extended Description: A buffer overflow condition exists when a product attempts to put more data in a buffer than it can hold, or when it attempts to put data in a memory area outside of the boundaries of a buffer. The simplest type of error, and the most common cause of buffer overflows, is the "classic" case in which the product copies the buffer without restricting how much is copied. Other variants exist, but the existence of a classic overflow strongly suggests that the programmer is not considering even the most basic of security protections.

--------------------------------------------------------------------------------

Title: CWE-121: Stack-based Buffer Overflow
Description: A stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function).
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-122: Heap-based Buffer Overflow
Description: A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-123: Write-what-where Condition
Description: Any condition where the attacker has the ability to write an arbitrary value to an arbitrary location, often as the result of a buffer overflow.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-124: Buffer Underwrite
Description: The product writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.
Extended Description: This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.

--------------------------------------------------------------------------------

Title: CWE-125: Out-of-bounds Read
Description: The product reads data past the end, or before the beginning, of the intended buffer.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-126: Buffer Over-read
Description: The product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations after the targeted buffer.
Extended Description: This typically occurs when the pointer or its index is incremented to a position beyond the bounds of the buffer or when pointer arithmetic results in a position outside of the valid memory location to name a few. This may result in exposure of sensitive information or possibly a crash.

--------------------------------------------------------------------------------

Title: CWE-127: Buffer Under-read
Description: The product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations prior to the targeted buffer.
Extended Description: This typically occurs when the pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used. This may result in exposure of sensitive information or possibly a crash.

--------------------------------------------------------------------------------

Title: CWE-128: Wrap-around Error
Description: Wrap around errors occur whenever a value is incremented past the maximum value for its type and therefore "wraps around" to a very small, negative, or undefined value.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-129: Improper Validation of Array Index
Description: The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-130: Improper Handling of Length Parameter Inconsistency
Description: The product parses a formatted message or structure, but it does not handle or incorrectly handles a length field that is inconsistent with the actual length of the associated data.
Extended Description: If an attacker can manipulate the length parameter associated with an input such that it is inconsistent with the actual length of the input, this can be leveraged to cause the target application to behave in unexpected, and possibly, malicious ways. One of the possible motives for doing so is to pass in arbitrarily large input to the application. Another possible motivation is the modification of application state by including invalid data for subsequent properties of the application. Such weaknesses commonly lead to attacks such as buffer overflows and execution of arbitrary code.

--------------------------------------------------------------------------------

Title: CWE-131: Incorrect Calculation of Buffer Size
Description: The product does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-134: Use of Externally-Controlled Format String
Description: The product uses a function that accepts a format string as an argument, but the format string originates from an external source.
Extended Description: When an attacker can modify an externally-controlled format string, this can lead to buffer overflows, denial of service, or data representation problems.It should be noted that in some circumstances, such as internationalization, the set of format strings is externally controlled by design. If the source of these format strings is trusted (e.g. only contained in library files that are only modifiable by the system administrator), then the external control might not itself pose a vulnerability.

--------------------------------------------------------------------------------

Title: CWE-135: Incorrect Calculation of Multi-Byte String Length
Description: The product does not correctly calculate the length of strings that can contain wide or multi-byte characters.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-170: Improper Null Termination
Description: The product does not terminate or incorrectly terminates a string or array with a null character or equivalent terminator.
Extended Description: Null termination errors frequently occur in two different ways. An off-by-one error could cause a null to be written out of bounds, leading to an overflow. Or, a program could use a strncpy() function call incorrectly, which prevents a null terminator from being added at all. Other scenarios are possible.

--------------------------------------------------------------------------------

Title: CWE-188: Reliance on Data/Memory Layout
Description: The product makes invalid assumptions about how protocol data or memory is organized at a lower level, resulting in unintended program behavior.
Extended Description: When changing platforms or protocol versions, in-memory organization of data may change in unintended ways. For example, some architectures may place local variables A and B right next to each other with A on top; some may place them next to each other with B on top; and others may add some padding to each. The padding size may vary to ensure that each variable is aligned to a proper word size.In protocol implementations, it is common to calculate an offset relative to another field to pick out a specific piece of data. Exceptional conditions, often involving new protocol versions, may add corner cases that change the data layout in an unusual way. The result can be that an implementation accesses an unintended field in the packet, treating data of one type as data of another type.

--------------------------------------------------------------------------------

Title: CWE-191: Integer Underflow
Description: The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.
Extended Description: This can happen in signed and unsigned cases.

--------------------------------------------------------------------------------

Title: CWE-192: Integer Coercion Error
Description: Integer coercion refers to a set of flaws pertaining to the type casting, extension, or truncation of primitive data types.
Extended Description: Several flaws fall under the category of integer coercion errors. For the most part, these errors in and of themselves result only in availability and data integrity issues. However, in some circumstances, they may result in other, more complicated security related flaws, such as buffer overflow conditions.

--------------------------------------------------------------------------------

Title: CWE-194: Unexpected Sign Extension
Description: The product performs an operation on a number that causes it to be sign extended when it is transformed into a larger data type. When the original number is negative, this can produce unexpected values that lead to resultant weaknesses.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-195: Signed to Unsigned Conversion Error
Description: The product uses a signed primitive and performs a cast to an unsigned primitive, which can produce an unexpected value if the value of the signed primitive can not be represented using an unsigned primitive.
Extended Description: It is dangerous to rely on implicit casts between signed and unsigned numbers because the result can take on an unexpected value and violate assumptions made by the program.Often, functions will return negative values to indicate a failure. When the result of a function is to be used as a size parameter, using these negative return values can have unexpected results. For example, if negative size values are passed to the standard memory copy or allocation functions they will be implicitly cast to a large unsigned value. This may lead to an exploitable buffer overflow or underflow condition.

--------------------------------------------------------------------------------

Title: CWE-196: Unsigned to Signed Conversion Error
Description: The product uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value if the value of the unsigned primitive can not be represented using a signed primitive.
Extended Description: Although less frequent an issue than signed-to-unsigned conversion, unsigned-to-signed conversion can be the perfect precursor to dangerous buffer underwrite conditions that allow attackers to move down the stack where they otherwise might not have access in a normal buffer overflow condition. Buffer underwrites occur frequently when large unsigned values are cast to signed values, and then used as indexes into a buffer or for pointer arithmetic.

--------------------------------------------------------------------------------

Title: CWE-197: Numeric Truncation Error
Description: Truncation errors occur when a primitive is cast to a primitive of a smaller size and data is lost in the conversion.
Extended Description: When a primitive is cast to a smaller primitive, the high order bits of the large value are lost in the conversion, potentially resulting in an unexpected value that is not equal to the original value. This value may be required as an index into a buffer, a loop iterator, or simply necessary state data. In any case, the value cannot be trusted and the system will be in an undefined state. While this method may be employed viably to isolate the low bits of a value, this usage is rare, and truncation usually implies that an implementation error has occurred.

--------------------------------------------------------------------------------

Title: CWE-242: Use of Inherently Dangerous Function
Description: The product calls a function that can never be guaranteed to work safely.
Extended Description: Certain functions behave in dangerous ways regardless of how they are used. Functions in this category were often implemented without taking security concerns into account. The gets() function is unsafe because it does not perform bounds checking on the size of its input. An attacker can easily send arbitrarily-sized input to gets() and overflow the destination buffer. Similarly, the >> operator is unsafe to use when reading into a statically-allocated character array because it does not perform bounds checking on the size of its input. An attacker can easily send arbitrarily-sized input to the >> operator and overflow the destination buffer.

--------------------------------------------------------------------------------

Title: CWE-243: Creation of chroot Jail Without Changing Working Directory
Description: The product uses the chroot() system call to create a jail, but does not change the working directory afterward. This does not prevent access to files outside of the jail.
Extended Description: Improper use of chroot() may allow attackers to escape from the chroot jail. The chroot() function call does not change the process's current working directory, so relative paths may still refer to file system resources outside of the chroot jail after chroot() has been called.

--------------------------------------------------------------------------------

Title: CWE-244: Improper Clearing of Heap Memory Before Release
Description: Using realloc() to resize buffers that store sensitive information can leave the sensitive information exposed to attack, because it is not removed from memory.
Extended Description: When sensitive data such as a password or an encryption key is not removed from memory, it could be exposed to an attacker using a "heap inspection" attack that reads the sensitive data using memory dumps or other methods. The realloc() function is commonly used to increase the size of a block of allocated memory. This operation often requires copying the contents of the old memory block into a new and larger block. This operation leaves the contents of the original block intact but inaccessible to the program, preventing the program from being able to scrub sensitive data from memory. If an attacker can later examine the contents of a memory dump, the sensitive data could be exposed.

--------------------------------------------------------------------------------

Title: CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization
Description: The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.
Extended Description: This can have security implications when the expected synchronization is in security-critical code, such as recording whether a user is authenticated or modifying important state information that should not be influenced by an outsider.A race condition occurs within concurrent environments, and is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc.A race condition violates these properties, which are closely related:Exclusivity - the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution.Atomicity - the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource.A race condition exists when an "interfering code sequence" can still access the shared resource, violating exclusivity. Programmers may assume that certain code sequences execute too quickly to be affected by an interfering code sequence; when they are not, this violates atomicity. For example, the single "x++" statement may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read (the original value of x), followed by a computation (x+1), followed by a write (save the result to x).The interfering code sequence could be "trusted" or "untrusted." A trusted interfering code sequence occurs within the product; it cannot be modified by the attacker, and it can only be invoked indirectly. An untrusted interfering code sequence can be authored directly by the attacker, and typically it is external to the vulnerable product.

--------------------------------------------------------------------------------

Title: CWE-364: Signal Handler Race Condition
Description: The product uses a signal handler that introduces a race condition.
Extended Description: Race conditions frequently occur in signal handlers, since signal handlers support asynchronous actions. These race conditions have a variety of root causes and symptoms. Attackers may be able to exploit a signal handler race condition to cause the product state to be corrupted, possibly leading to a denial of service or even code execution.These issues occur when non-reentrant functions, or state-sensitive actions occur in the signal handler, where they may be called at any time. These behaviors can violate assumptions being made by the "regular" code that is interrupted, or by other signal handlers that may also be invoked. If these functions are called at an inopportune moment - such as while a non-reentrant function is already running - memory corruption could occur that may be exploitable for code execution. Another signal race condition commonly found occurs when free is called within a signal handler, resulting in a double free and therefore a write-what-where condition. Even if a given pointer is set to NULL after it has been freed, a race condition still exists between the time the memory was freed and the pointer was set to NULL. This is especially problematic if the same signal handler has been set for more than one signal -- since it means that the signal handler itself may be reentered.There are several known behaviors related to signal handlers that have received the label of "signal handler race condition":Shared state (e.g. global data or static variables) that are accessible to both a signal handler and "regular" codeShared state between a signal handler and other signal handlersUse of non-reentrant functionality within a signal handler - which generally implies that shared state is being used. For example, malloc() and free() are non-reentrant because they may use global or static data structures for managing memory, and they are indirectly used by innocent-seeming functions such as syslog(); these functions could be exploited for memory corruption and, possibly, code execution.Association of the same signal handler function with multiple signals - which might imply shared state, since the same code and resources are accessed. For example, this can be a source of double-free and use-after-free weaknesses.Use of setjmp and longjmp, or other mechanisms that prevent a signal handler from returning control back to the original functionalityWhile not technically a race condition, some signal handlers are designed to be called at most once, and being called more than once can introduce security problems, even when there are not any concurrent calls to the signal handler. This can be a source of double-free and use-after-free weaknesses.Signal handler vulnerabilities are often classified based on the absence of a specific protection mechanism, although this style of classification is discouraged in CWE because programmers often have a choice of several different mechanisms for addressing the weakness. Such protection mechanisms may preserve exclusivity of access to the shared resource, and behavioral atomicity for the relevant code:Avoiding shared stateUsing synchronization in the signal handlerUsing synchronization in the regular codeDisabling or masking other signals, which provides atomicity (which effectively ensures exclusivity)

--------------------------------------------------------------------------------

Title: CWE-366: Race Condition within a Thread
Description: If two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-374: Passing Mutable Objects to an Untrusted Method
Description: The product sends non-cloned mutable data as an argument to a method or function.
Extended Description: The function or method that has been called can alter or delete the mutable data. This could violate assumptions that the calling function has made about its state. In situations where unknown code is called with references to mutable data, this external code could make changes to the data sent. If this data was not previously cloned, the modified data might not be valid in the context of execution.

--------------------------------------------------------------------------------

Title: CWE-375: Returning a Mutable Object to an Untrusted Caller
Description: Sending non-cloned mutable data as a return value may result in that data being altered or deleted by the calling function.
Extended Description: In situations where functions return references to mutable data, it is possible that the external code which called the function may make changes to the data sent. If this data was not previously cloned, the class will then be using modified data which may violate assumptions about its internal state.

--------------------------------------------------------------------------------

Title: CWE-401: Missing Release of Memory after Effective Lifetime
Description: The product does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.
Extended Description: This is often triggered by improper handling of malformed data or unexpectedly interrupted sessions. In some languages, developers are responsible for tracking memory allocation and releasing the memory. If there are no more pointers or references to the memory, then it can no longer be tracked and identified for release.

--------------------------------------------------------------------------------

Title: CWE-415: Double Free
Description: The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.
Extended Description: When a program calls free() twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack.

--------------------------------------------------------------------------------

Title: CWE-416: Use After Free
Description: The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory "belongs" to the code that operates on the new pointer.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-457: Use of Uninitialized Variable
Description: The code uses a variable that has not been initialized, leading to unpredictable or unintended results.
Extended Description: In some languages such as C and C++, stack variables are not initialized by default. They generally contain junk data with the contents of stack memory before the function was invoked. An attacker can sometimes control or read these contents. In other languages or conditions, a variable that is not explicitly initialized can be given a default value that has security implications, depending on the logic of the program. The presence of an uninitialized variable can sometimes indicate a typographic error in the code.

--------------------------------------------------------------------------------

Title: CWE-460: Improper Cleanup on Thrown Exception
Description: The product does not clean up its state or incorrectly cleans up its state when an exception is thrown, leading to unexpected state or control flow.
Extended Description: Often, when functions or loops become complicated, some level of resource cleanup is needed throughout execution. Exceptions can disturb the flow of the code and prevent the necessary cleanup from happening.

--------------------------------------------------------------------------------

Title: CWE-462: Duplicate Key in Associative List
Description: Duplicate keys in associative lists can lead to non-unique keys being mistaken for an error.
Extended Description: A duplicate key entry -- if the alist is designed properly -- could be used as a constant time replace function. However, duplicate key entries could be inserted by mistake. Because of this ambiguity, duplicate key entries in an association list are not recommended and should not be allowed.

--------------------------------------------------------------------------------

Title: CWE-463: Deletion of Data Structure Sentinel
Description: The accidental deletion of a data-structure sentinel can cause serious programming logic problems.
Extended Description: Often times data-structure sentinels are used to mark structure of the data structure. A common example of this is the null character at the end of strings. Another common example is linked lists which may contain a sentinel to mark the end of the list. It is dangerous to allow this type of control data to be easily accessible. Therefore, it is important to protect from the deletion or modification outside of some wrapper interface which provides safety.

--------------------------------------------------------------------------------

Title: CWE-464: Addition of Data Structure Sentinel
Description: The accidental addition of a data-structure sentinel can cause serious programming logic problems.
Extended Description: Data-structure sentinels are often used to mark the structure of data. A common example of this is the null character at the end of strings or a special sentinel to mark the end of a linked list. It is dangerous to allow this type of control data to be easily accessible. Therefore, it is important to protect from the addition or modification of sentinels.

--------------------------------------------------------------------------------

Title: CWE-466: Return of Pointer Value Outside of Expected Range
Description: A function can return a pointer to memory that is outside of the buffer that the pointer is expected to reference.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-467: Use of sizeof
Description: The code calls sizeof() on a malloced pointer type, which always returns the wordsize/8. This can produce an unexpected result if the programmer intended to determine how much memory has been allocated.
Extended Description: The use of sizeof() on a pointer can sometimes generate useful information. An obvious case is to find out the wordsize on a platform. More often than not, the appearance of sizeof(pointer) indicates a bug.

--------------------------------------------------------------------------------

Title: CWE-468: Incorrect Pointer Scaling
Description: In C and C++, one may often accidentally refer to the wrong memory due to the semantics of when math operations are implicitly scaled.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-469: Use of Pointer Subtraction to Determine Size
Description: The product subtracts one pointer from another in order to determine size, but this calculation can be incorrect if the pointers do not exist in the same memory chunk.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-474: Use of Function with Inconsistent Implementations
Description: The code uses a function that has inconsistent implementations across operating systems and versions.
Extended Description: The use of inconsistent implementations can cause changes in behavior when the code is ported or built under a different environment than the programmer expects, which can lead to security problems in some cases.The implementation of many functions varies by platform, and at times, even by different versions of the same platform. Implementation differences can include:Slight differences in the way parameters are interpreted leading to inconsistent results.Some implementations of the function carry significant security risks.The function might not be defined on all platforms.The function might change which return codes it can provide, or change the meaning of its return codes.

--------------------------------------------------------------------------------

Title: CWE-476: NULL Pointer Dereference
Description: The product dereferences a pointer that it expects to be valid but is NULL.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-478: Missing Default Case in Multiple Condition Expression
Description: The code does not have a default case in an expression with multiple conditions, such as a switch statement.
Extended Description: If a multiple-condition expression (such as a switch in C) omits the default case but does not consider or handle all possible values that could occur, then this might lead to complex logical errors and resultant weaknesses. Because of this, further decisions are made based on poor information, and cascading failure results. This cascading failure may result in any number of security issues, and constitutes a significant failure in the system.

--------------------------------------------------------------------------------

Title: CWE-479: Signal Handler Use of a Non-reentrant Function
Description: The product defines a signal handler that calls a non-reentrant function.
Extended Description: Non-reentrant functions are functions that cannot safely be called, interrupted, and then recalled before the first call has finished without resulting in memory corruption. This can lead to an unexpected system state and unpredictable results with a variety of potential consequences depending on context, including denial of service and code execution.Many functions are not reentrant, but some of them can result in the corruption of memory if they are used in a signal handler. The function call syslog() is an example of this. In order to perform its functionality, it allocates a small amount of memory as "scratch space." If syslog() is suspended by a signal call and the signal handler calls syslog(), the memory used by both of these functions enters an undefined, and possibly, exploitable state. Implementations of malloc() and free() manage metadata in global structures in order to track which memory is allocated versus which memory is available, but they are non-reentrant. Simultaneous calls to these functions can cause corruption of the metadata.

--------------------------------------------------------------------------------

Title: CWE-480: Use of Incorrect Operator
Description: The product accidentally uses the wrong operator, which changes the logic in security-relevant ways.
Extended Description: These types of errors are generally the result of a typo by the programmer.

--------------------------------------------------------------------------------

Title: CWE-481: Assigning instead of Comparing
Description: The code uses an operator for assignment when the intention was to perform a comparison.
Extended Description: In many languages the compare statement is very close in appearance to the assignment statement and are often confused. This bug is generally the result of a typo and usually causes obvious problems with program execution. If the comparison is in an if statement, the if statement will usually evaluate the value of the right-hand side of the predicate.

--------------------------------------------------------------------------------

Title: CWE-482: Comparing instead of Assigning
Description: The code uses an operator for comparison when the intention was to perform an assignment.
Extended Description: In many languages, the compare statement is very close in appearance to the assignment statement; they are often confused.

--------------------------------------------------------------------------------

Title: CWE-483: Incorrect Block Delimitation
Description: The code does not explicitly delimit a block that is intended to contain 2 or more statements, creating a logic error.
Extended Description: In some languages, braces (or other delimiters) are optional for blocks. When the delimiter is omitted, it is possible to insert a logic error in which a statement is thought to be in a block but is not. In some cases, the logic error can have security implications.

--------------------------------------------------------------------------------

Title: CWE-484: Omitted Break Statement in Switch
Description: The product omits a break statement within a switch or similar construct, causing code associated with multiple conditions to execute. This can cause problems when the programmer only intended to execute code associated with one condition.
Extended Description: This can lead to critical code executing in situations where it should not.

--------------------------------------------------------------------------------

Title: CWE-495: Private Data Structure Returned From A Public Method
Description: The product has a method that is declared public, but returns a reference to a private data structure, which could then be modified in unexpected ways.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-496: Public Data Assigned to Private Array-Typed Field
Description: Assigning public data to a private array is equivalent to giving public access to the array.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-558: Use of getlogin
Description: The product uses the getlogin() function in a multithreaded context, potentially causing it to return incorrect values.
Extended Description: The getlogin() function returns a pointer to a string that contains the name of the user associated with the calling process. The function is not reentrant, meaning that if it is called from another process, the contents are not locked out and the value of the string can be changed by another process. This makes it very risky to use because the username can be changed by other processes, so the results of the function cannot be trusted.

--------------------------------------------------------------------------------

Title: CWE-560: Use of umask
Description: The product calls umask() with an incorrect argument that is specified as if it is an argument to chmod().
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-562: Return of Stack Variable Address
Description: A function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash.
Extended Description: Because local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to re-use this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function's stack frame is invalidated when it returns. At best this will cause the value of the pointer to change unexpectedly. In many cases it causes the program to crash the next time the pointer is dereferenced.

--------------------------------------------------------------------------------

Title: CWE-587: Assignment of a Fixed Address to a Pointer
Description: The product sets a pointer to a specific address other than NULL or 0.
Extended Description: Using a fixed address is not portable, because that address will probably not be valid in all environments or platforms.

--------------------------------------------------------------------------------

Title: CWE-676: Use of Potentially Dangerous Function
Description: The product invokes a potentially dangerous function that could introduce a vulnerability if it is used incorrectly, but the function can also be used safely.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-685: Function Call With Incorrect Number of Arguments
Description: The product calls a function, procedure, or routine, but the caller specifies too many arguments, or too few arguments, which may lead to undefined behavior and resultant weaknesses.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-688: Function Call With Incorrect Variable or Reference as Argument
Description: The product calls a function, procedure, or routine, but the caller specifies the wrong variable or reference as one of the arguments, which may lead to undefined behavior and resultant weaknesses.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-689: Permission Race Condition During Resource Copy
Description: The product, while copying or cloning a resource, does not set the resource's permissions or access control until the copy is complete, leaving the resource exposed to other spheres while the copy is taking place.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-690: Unchecked Return Value to NULL Pointer Dereference
Description: The product does not check for an error after calling a function that can return with a NULL pointer if the function fails, which leads to a resultant NULL pointer dereference.
Extended Description: While unchecked return value weaknesses are not limited to returns of NULL pointers (see the examples inCWE-252), functions often return NULL to indicate an error status. When this error condition is not checked, a NULL pointer dereference can occur.

--------------------------------------------------------------------------------

Title: CWE-704: Incorrect Type Conversion or Cast
Description: The product does not correctly convert an object, resource, or structure from one type to a different type.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-733: Compiler Optimization Removal or Modification of Security-critical Code
Description: The developer builds a security-critical protection mechanism into the software, but the compiler optimizes the program such that the mechanism is removed or modified.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-762: Mismatched Memory Management Routines
Description: The product attempts to return a memory resource to the system, but it calls a release function that is not compatible with the function that was originally used to allocate that resource.
Extended Description: This weakness can be generally described as mismatching memory management routines, such as:The memory was allocated on the stack (automatically), but it was deallocated using the memory management routine free() (CWE-590), which is intended for explicitly allocated heap memory.The memory was allocated explicitly using one set of memory management functions, and deallocated using a different set. For example, memory might be allocated with malloc() in C++ instead of the new operator, and then deallocated with the delete operator.When the memory management functions are mismatched, the consequences may be as severe as code execution, memory corruption, or program crash. Consequences and ease of exploit will vary depending on the implementation of the routines and the object being managed.

--------------------------------------------------------------------------------

Title: CWE-781: Improper Address Validation in IOCTL with METHOD_NEITHER I/O Control Code
Description: The product defines an IOCTL that uses METHOD_NEITHER for I/O, but it does not validate or incorrectly validates the addresses that are provided.
Extended Description: When an IOCTL uses the METHOD_NEITHER option for I/O control, it is the responsibility of the IOCTL to validate the addresses that have been supplied to it. If validation is missing or incorrect, attackers can supply arbitrary memory addresses, leading to code execution or a denial of service.

--------------------------------------------------------------------------------

Title: CWE-782: Exposed IOCTL with Insufficient Access Control
Description: The product implements an IOCTL with functionality that should be restricted, but it does not properly enforce access control for the IOCTL.
Extended Description: When an IOCTL contains privileged functionality and is exposed unnecessarily, attackers may be able to access this functionality by invoking the IOCTL. Even if the functionality is benign, if the programmer has assumed that the IOCTL would only be accessed by a trusted process, there may be little or no validation of the incoming data, exposing weaknesses that would never be reachable if the attacker cannot call the IOCTL directly.The implementations of IOCTLs will differ between operating system types and versions, so the methods of attack and prevention may vary widely.

--------------------------------------------------------------------------------

Title: CWE-783: Operator Precedence Logic Error
Description: The product uses an expression in which operator precedence causes incorrect logic to be used.
Extended Description: While often just a bug, operator precedence logic errors can have serious consequences if they are used in security-critical code, such as making an authentication decision.

--------------------------------------------------------------------------------

Title: CWE-785: Use of Path Manipulation Function without Maximum-sized Buffer
Description: The product invokes a function for normalizing paths or file names, but it provides an output buffer that is smaller than the maximum possible size, such as PATH_MAX.
Extended Description: Passing an inadequately-sized output buffer to a path manipulation function can result in a buffer overflow. Such functions include realpath(), readlink(), PathAppend(), and others.

--------------------------------------------------------------------------------

Title: CWE-787: Out-of-bounds Write
Description: The product writes data past the end, or before the beginning, of the intended buffer.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-789: Memory Allocation with Excessive Size Value
Description: The product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.
Extended Description: Extended Description not found

--------------------------------------------------------------------------------

Title: CWE-805: Buffer Access with Incorrect Length Value
Description: The product uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.
Extended Description: When the length value exceeds the size of the destination, a buffer overflow could occur.

--------------------------------------------------------------------------------

Title: CWE-806: Buffer Access Using Size of Source Buffer
Description: The product uses the size of a source buffer when reading from or writing to a destination buffer, which may cause it to access memory that is outside of the bounds of the buffer.
Extended Description: When the size of the destination is smaller than the size of the source, a buffer overflow could occur.

--------------------------------------------------------------------------------

Title: CWE-839: Numeric Range Comparison Without Minimum Check
Description: The product checks a value to ensure that it is less than or equal to a maximum, but it does not also verify that the value is greater than or equal to the minimum.
Extended Description: Some products use signed integers or floats even when their values are only expected to be positive or 0. An input validation check might assume that the value is positive, and only check for the maximum value. If the value is negative, but the code assumes that the value is positive, this can produce an error. The error may have security consequences if the negative value is used for memory allocation, array access, buffer access, etc. Ultimately, the error could lead to a buffer overflow or other type of memory corruption.The use of a negative number in a positive-only context could have security implications for other types of resources. For example, a shopping cart might check that the user is not requesting more than 10 items, but a request for -3 items could cause the application to calculate a negative price and credit the attacker's account.

--------------------------------------------------------------------------------

Title: CWE-843: Access of Resource Using Incompatible Type
Description: The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.
Extended Description: When the product accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access.While this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways.This weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues.

--------------------------------------------------------------------------------

Title: CWE-910: Use of Expired File Descriptor
Description: The product uses or accesses a file descriptor after it has been closed.
Extended Description: After a file descriptor for a particular file or device has been released, it can be reused. The code might not write to the original file, since the reused file descriptor might reference a different file or device.

--------------------------------------------------------------------------------

Title: CWE-911: Improper Update of Reference Count
Description: The product uses a reference count to manage a resource, but it does not update or incorrectly updates the reference count.
Extended Description: Reference counts can be used when tracking how many objects contain a reference to a particular resource, such as in memory management or garbage collection. When the reference count reaches zero, the resource can be de-allocated or reused because there are no more objects that use it. If the reference count accidentally reaches zero, then the resource might be released too soon, even though it is still in use. If all objects no longer use the resource, but the reference count is not zero, then the resource might not ever be released.

--------------------------------------------------------------------------------

Title: CWE-1325: Improperly Controlled Sequential Memory Allocation
Description: The product manages a group of objects or resources and performs a separate memory allocation for each object, but it does not properly limit the total amount of memory that is consumed by all of the combined objects.
Extended Description: While the product might limit the amount of memory that is allocated in a single operation for a single object (such as a malloc of an array), if an attacker can cause multiple objects to be allocated in separate operations, then this might cause higher total memory consumption than the developer intended, leading to a denial of service.

--------------------------------------------------------------------------------

Title: CWE-1335: Incorrect Bitwise Shift of Integer
Description: An integer value is specified to be shifted by a negative amount or an amount greater than or equal to the number of bits contained in the value causing an unexpected or indeterminate result.
Extended Description: Specifying a value to be shifted by a negative amount is undefined in various languages. Various computer architectures implement this action in different ways. The compilers and interpreters when generating code to accomplish a shift generally do not do a check for this issue.Specifying an over-shift, a shift greater than or equal to the number of bits contained in a value to be shifted, produces a result which varies by architecture and compiler. In some languages, this action is specifically listed as producing an undefined result.

--------------------------------------------------------------------------------

Title: CWE-1341: Multiple Releases of Same Resource or Handle
Description: The product attempts to close or release a resource or handle more than once, without any successful open between the close operations.
Extended Description: Code typically requires "opening" handles or references to resources such as memory, files, devices, socket connections, services, etc. When the code is finished with using the resource, it is typically expected to "close" or "release" the resource, which indicates to the environment (such as the OS) that the resource can be re-assigned or reused by unrelated processes or actors - or in some cases, within the same process. API functions or other abstractions are often used to perform this release, such as free() or delete() within C/C++, or file-handle close() operations that are used in many languages.Unfortunately, the implementation or design of such APIs might expect the developer to be responsible for ensuring that such APIs are only called once per release of the resource. If the developer attempts to release the same resource/handle more than once, then the API's expectations are not met, resulting in undefined and/or insecure behavior. This could lead to consequences such as memory corruption, data corruption, execution path corruption, or other consequences.Note that while the implementation for most (if not all) resource reservation allocations involve a unique identifier/pointer/symbolic reference, then if this identifier is reused, checking the identifier for resource closure may result in a false state of openness and closing of the wrong resource. For this reason, reuse of identifiers is discouraged.

--------------------------------------------------------------------------------

