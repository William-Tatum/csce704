#include <stdio.h>
#include <string.h>

void clear_memory(char *buffer, size_t length) {
    volatile char *volatile_buffer = (volatile char *)buffer;
    for (size_t i = 0; i < length; i++) {
        volatile_buffer[i] = 0;
    }
}

int main() {
    char sensitive_data[100];
    strcpy(sensitive_data, "This is some sensitive data");
    printf("Sensitive data: %s\n", sensitive_data);
    clear_memory(sensitive_data, sizeof(sensitive_data));
    // Code does not use sensitive_data anymore
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

void vulnerableFunction(char *input) {
    char buffer[10];
    for (int i = 0; i <= 10; i++) {
        buffer[i] = input[i];
    }
    printf("Buffer content: %s\n", buffer);
}

int main() {
    char userInput[15] = "Hello, World!";
    vulnerableFunction(userInput);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

void copy_data(const char *input) {
    char buffer[10];
    strcpy(buffer, input);
    printf("Buffer contains: %s\n", buffer);
}

int main() {
    char input_data[100];
    printf("Enter some data: ");
    fgets(input_data, sizeof(input_data), stdin);
    copy_data(input_data);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

void processInput(char *input) {
    char buffer[10];
    strcpy(buffer, input);
    printf("Processed input: %s\n", buffer);
}

int main() {
    char userInput[100];
    printf("Enter some text: ");
    fgets(userInput, sizeof(userInput), stdin);
    processInput(userInput);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *buffer;
    buffer = (char *)malloc(10 * sizeof(char));
    if (buffer == NULL) {
        return 1;
    }
    strcpy(buffer, "This string is way too long!");
    printf("%s\n", buffer);
    free(buffer);
    return 0;
}

--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);
}

int main(int argc, char *argv[]) {
    if (argc > 1) {
        vulnerable_function(argv[1]);
    } else {
        printf("Please provide an input string.\n");
    }
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

void writeToBuffer(char *input) {
    char buffer[10];
    char *ptr = buffer;
    ptr--; 
    strcpy(ptr, input);
}

int main() {
    char data[] = "HelloWorld!";
    writeToBuffer(data);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

void readBuffer(int *arr, int size) {
    for (int i = 0; i <= size; i++) {
        printf("%d\n", arr[i]);
    }
}

int main() {
    int buffer[5] = {1, 2, 3, 4, 5};
    readBuffer(buffer, 5);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

void printLine(const char *str) {
    char buffer[10];
    strcpy(buffer, str);
    for (int i = 0; i <= 10; i++) {
        putchar(buffer[i]);
    }
}

int main() {
    const char *inputString = "HelloWorld";
    printLine(inputString);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

void buffer_underread() {
    char buffer[10];
    char *data;
    strcpy(buffer, "ABCDEFGHIJ");
    data = buffer - 1;
    printf("Buffer contents: %c\n", *data);
}

int main() {
    buffer_underread();
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <limits.h>

int main() {
    unsigned int value = UINT_MAX;
    printf("Initial value: %u\n", value);
    value++;
    printf("Value after increment: %u\n", value); // Wrap-around error occurs here
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

int main() {
    int index;
    int data[10];
    printf("Enter an array index: ");
    scanf("%d", &index);
    data[index] = 100;
    printf("Data at index %d is %d\n", index, data[index]);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define BUFFER_SIZE 256

void process_message(const char *msg, size_t len) {
    char buffer[BUFFER_SIZE];
    if (len > BUFFER_SIZE) {
        printf("Error: Length exceeds buffer size.\n");
        return;
    }
    memcpy(buffer, msg, len);
    buffer[len] = '\0';
    printf("Processed message: %s\n", buffer);
}

int main() {
    char input[] = "This is a test message. It is longer than expected.";
    size_t input_len = strlen(input); // Actual length
    size_t specified_len = 60; // Incorrectly specified length

    process_message(input, specified_len);

    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void vulnerableFunction(const char *input) {
    int length = strlen(input);
    char *buffer = (char *)malloc(length); // Incorrect calculation: does not allocate space for null terminator

    if (buffer == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }

    strcpy(buffer, input); // Potential buffer overflow
    printf("Buffer contents: %s\n", buffer);

    free(buffer);
}

int main() {
    char userInput[100];
    printf("Enter some text: ");
    fgets(userInput, sizeof(userInput), stdin);
    strtok(userInput, "\n"); // Remove newline character

    vulnerableFunction(userInput);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

void print_input(char *user_input) {
    printf(user_input);
}

int main() {
    char user_input[256];
    fgets(user_input, sizeof(user_input), stdin);
    print_input(user_input);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>
#include <wchar.h>

int main() {
    char multi_byte_str[] = "こんにちは"; // "Hello" in Japanese
    wchar_t wide_char_str[] = L"こんにちは"; 

    int len_incorrect = strlen((char*)wide_char_str);

    printf("Incorrect Length Calculation: %d\n", len_incorrect);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

int main() {
    char source[] = "This is a long string";
    char destination[10];
    
    strncpy(destination, source, sizeof(destination));
    
    printf("Destination: %s\n", destination);
    
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

struct PacketV1 {
    int header;
    char data[8];
};

struct PacketV2 {
    int header;
    int padding;
    char data[8];
};

void processPacket(char *packet, int version) {
    if (version == 1) {
        struct PacketV1 *pktV1 = (struct PacketV1 *)packet;
        printf("Processing V1: %s\n", pktV1->data);
    } else if (version == 2) {
        struct PacketV2 *pktV2 = (struct PacketV2 *)packet;
        printf("Processing V2: %s\n", pktV2->data);
    }
}

int main() {
    char buffer[20];
    memcpy(buffer, "\x01\x00\x00\x00HelloV1", 12);
    processPacket(buffer, 1);

    memcpy(buffer, "\x02\x00\x00\x00\x00\x00\x00\x00HelloV2", 16);
    processPacket(buffer, 2);

    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <limits.h>

int main() {
    int a = INT_MIN;
    int b = 1;
    int result = a - b;
    printf("Result: %d\n", result);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

int main() {
    unsigned int largeNumber = 3000000000;
    int coercedNumber = largeNumber;
    printf("Original unsigned number: %u\n", largeNumber);
    printf("Coerced signed number: %d\n", coercedNumber);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

void processNumber(unsigned short num) {
    int extendedNum;
    extendedNum = num;
    printf("Processed number: %d\n", extendedNum);
}

int main() {
    unsigned short num;
    printf("Enter a number: ");
    scanf("%hd", &num);
    processNumber(num);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int getValue() {
    return -5;
}

int main() {
    int signedValue = getValue();
    size_t size = (size_t)signedValue;
    
    char* buffer = (char*)malloc(size);
    if (buffer == NULL) {
        printf("Memory allocation failed\n");
        return 1;
    }
    
    strcpy(buffer, "Hello, World!");
    printf("%s\n", buffer);
    
    free(buffer);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

void process_buffer(char *buffer, unsigned int index) {
    int signed_index = (int)index;
    buffer[signed_index] = 'X';
}

int main() {
    char buffer[10];
    memset(buffer, 'A', sizeof(buffer));
    unsigned int large_index = 3000000000U;
    process_buffer(buffer, large_index);
    printf("%s\n", buffer);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

int main() {
    int largeValue = 300;
    char truncatedValue = (char)largeValue;
    printf("Original value: %d\n", largeValue);
    printf("Truncated value: %d\n", truncatedValue);
    return 0;
}

--------------------------------------------------------------------------------

#include <stdio.h>

int main() {
    char buffer[50];
    gets(buffer);
    printf("Input: %s\n", buffer);
    return 0;
}


--------------------------------------------------------------------------------

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    if (chroot("/var/jail") != 0) {
        perror("chroot failed");
        exit(EXIT_FAILURE);
    }

    // Code inside the chroot jail
    system("/bin/sh");

    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *sensitive_data = (char *)malloc(100 * sizeof(char));
    if (sensitive_data == NULL) {
        return -1;
    }
    
    strcpy(sensitive_data, "VerySecretPassword123");
    printf("Sensitive data: %s\n", sensitive_data);
    
    sensitive_data = (char *)realloc(sensitive_data, 200 * sizeof(char));
    if (sensitive_data == NULL) {
        return -1;
    }
    
    // Continue using sensitive_data but old data may remain in memory
    
    free(sensitive_data);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <pthread.h>

int shared_resource = 0;

void* increment_resource(void* arg) {
    int temp = shared_resource;
    temp = temp + 1;
    shared_resource = temp;
    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    pthread_create(&thread1, NULL, increment_resource, NULL);
    pthread_create(&thread2, NULL, increment_resource, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    printf("Shared Resource Value: %d\n", shared_resource);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

volatile int shared_var = 0;

void handler(int sig) {
    if (shared_var == 1) {
        // Potential race condition with shared_var
        free(malloc(128)); // Non-reentrant functions in a signal handler
        shared_var = 0; // Modify shared state
    }
}

int main() {
    signal(SIGINT, handler);
    signal(SIGTERM, handler);

    while(1) {
        shared_var = 1;
        sleep(1); // Simulate work
    }
    return 0;
}


--------------------------------------------------------------------------------

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

int shared_resource = 0;

void *thread_function(void *arg) {
    int local_copy = shared_resource;
    usleep(1); 
    local_copy++;
    shared_resource = local_copy;
    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    pthread_create(&thread1, NULL, thread_function, NULL);
    pthread_create(&thread2, NULL, thread_function, NULL);
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    printf("Final value of shared_resource: %d\n", shared_resource);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

void untrustedFunction(char *data) {
    strcpy(data, "Modified by untrusted function");
}

int main() {
    char mutableData[50] = "Original data";
    printf("Before: %s\n", mutableData);
    untrustedFunction(mutableData);
    printf("After: %s\n", mutableData);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

char* getSecretData() {
    static char secretData[100];
    strcpy(secretData, "Sensitive Information");
    return secretData;
}

int main() {
    char* data = getSecretData();
    printf("Before modification: %s\n", data);
    strcpy(data, "Tampered Information");
    printf("After modification: %s\n", getSecretData());
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void handle_data(const char *input) {
    char *data = (char *)malloc(100);
    if (data == NULL) {
        return;
    }
    strcpy(data, input);
    printf("Data: %s\n", data);
}

int main() {
    handle_data("Example data");
    return 0;
}


--------------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

int main() {
    char *ptr = (char *)malloc(10 * sizeof(char));
    if (ptr == NULL) {
        return 1;
    }

    free(ptr);
    free(ptr);

    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *data = (char *)malloc(10 * sizeof(char));
    if (data == NULL) {
        return -1;
    }

    strcpy(data, "Hello");

    free(data);

    char *newData = (char *)malloc(10 * sizeof(char));
    if (newData == NULL) {
        return -1;
    }

    strcpy(newData, "World");

    printf("%s\n", data); 

    free(newData);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

void printValue() {
    int x;
    printf("Value of x: %d\n", x);
}

int main() {
    printValue();
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>

jmp_buf env;

void cleanup_resources(char *buffer, FILE *file) {
    if (buffer) {
        free(buffer);
    }
    if (file) {
        fclose(file);
    }
}

void process_file(const char *filename) {
    char *buffer = (char *)malloc(1024);
    FILE *file = fopen(filename, "r");

    if (!buffer || !file) {
        longjmp(env, 1); 
    }

    // ...perform operations that might throw...

    cleanup_resources(buffer, file);
}

int main() {
    if (setjmp(env) != 0) {
        printf("Exception caught, resources not cleaned properly\n");
        return 1;
    }

    process_file("example.txt");

    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

typedef struct {
    char key[20];
    int value;
} AssocList;

int main() {
    AssocList alist[3] = {
        {"key1", 10},
        {"key2", 20},
        {"key1", 30}
    };

    const char *search_key = "key1";
    for(int i = 0; i < 3; i++) {
        if(strcmp(alist[i].key, search_key) == 0) {
            printf("Found key: %s, Value: %d\n", alist[i].key, alist[i].value);
        }
    }

    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node* next;
} Node;

Node* createListWithSentinel() {
    Node* sentinel = (Node*)malloc(sizeof(Node));
    if (sentinel == NULL) {
        exit(1);
    }
    sentinel->next = NULL;
    return sentinel;
}

void appendNode(Node* sentinel, int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (newNode == NULL) {
        exit(1);
    }
    newNode->data = value;
    newNode->next = sentinel->next;
    sentinel->next = newNode;
}

void printList(Node* sentinel) {
    Node* current = sentinel->next;
    while (current != NULL) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}

void deleteNode(Node* sentinel, int value) {
    Node* current = sentinel;
    while (current->next != NULL) {
        if (current->next->data == value) {
            Node* temp = current->next;
            current->next = temp->next;
            free(temp);
            break;
        }
        current = current->next;
    }
}

void unsafeDeleteSentinel(Node* sentinel) {
    if (sentinel != NULL) {
        free(sentinel);
    }
}

int main() {
    Node* sentinel = createListWithSentinel();
    appendNode(sentinel, 1);
    appendNode(sentinel, 2);
    appendNode(sentinel, 3);
    printList(sentinel);
    deleteNode(sentinel, 2);
    printList(sentinel);
    unsafeDeleteSentinel(sentinel);
    printList(sentinel);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

void processString(char *input) {
    char buffer[10];
    strcpy(buffer, input);
    printf("Processed string: %s\n", buffer);
}

int main() {
    char user_input[11]; // user inputs a string, including the null byte
    printf("Enter a string (max 10 characters): ");
    fgets(user_input, sizeof(user_input), stdin);
    user_input[strcspn(user_input, "\n")] = '\0'; // Remove newline character

    processString(user_input);

    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

char* get_string(char* strings[], int index, int size) {
    if (index >= size) {
        return strings[size - 1] + 5; // Returns a pointer outside the expected range
    }
    return strings[index];
}

int main() {
    char* strings[] = {"Hello", "World", "Example"};
    int size = sizeof(strings) / sizeof(strings[0]);
    char* result = get_string(strings, 3, size); // Index is out of range
    printf("%s\n", result);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *buffer = malloc(64);
    if (buffer == NULL) {
        perror("Failed to allocate memory");
        return 1;
    }

    strcpy(buffer, "This is a test string.");

    printf("Buffer size: %zu\n", sizeof(buffer));

    free(buffer);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

int main() {
    int array[10];
    int *ptr = array;
    int index = 5;
    int incorrectValue = *(ptr + index * sizeof(int));
    printf("Incorrect value: %d\n", incorrectValue);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *firstChunk = (char *)malloc(10 * sizeof(char));
    char *secondChunk = (char *)malloc(10 * sizeof(char));

    strcpy(firstChunk, "Hello");
    strcpy(secondChunk, "World");

    ptrdiff_t incorrectSize = secondChunk - firstChunk;
    printf("Incorrect size: %td\n", incorrectSize);

    free(firstChunk);
    free(secondChunk);

    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

int main() {
    char source[] = "This is a test string.";
    char dest[20];
    
    strncpy(dest, source, strlen(source) + 1);
    printf("Destination: %s\n", dest);
    
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

void printMessage(char *message) {
    printf("%s\n", message);
}

int main() {
    char *msg = NULL;
    printMessage(msg);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

void processInput(int input) {
    switch (input) {
        case 1:
            printf("Option 1 selected.\n");
            break;
        case 2:
            printf("Option 2 selected.\n");
            break;
        case 3:
            printf("Option 3 selected.\n");
            break;
        // Missing default case
    }
}

int main() {
    int input;
    printf("Enter a number: ");
    scanf("%d", &input);
    processInput(input);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <syslog.h>

void signal_handler(int signal) {
    syslog(LOG_INFO, "Signal received: %d", signal);
}

int main() {
    signal(SIGINT, signal_handler);
    openlog("CWE-479", LOG_PID | LOG_CONS, LOG_USER);
    while(1) {
        pause();
    }
    closelog();
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

int main() {
    int validUser = 0; // 0 means false, 1 means true

    // Incorrect operator used: '==' intended instead of '='
    if (validUser = 1) {
        printf("Access granted.\n");
    } else {
        printf("Access denied.\n");
    }

    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

int main() {
    int x = 5;
    int y = 10;
    
    if (x = y) {
        printf("This will always print because of assignment.\n");
    } else {
        printf("This will never print.\n");
    }
    
    printf("Value of x is: %d\n", x);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

int main() {
    int a = 5;
    int b = 10;
    if (a == b) {
        printf("a is equal to b\n");
    } else {
        printf("a is not equal to b\n");
    }
    a == b;
    printf("a: %d, b: %d\n", a, b);
    return 0;
}

--------------------------------------------------------------------------------

#include <stdio.h>

void checkValue(int x) {
    if (x > 0)
        printf("The value is positive.\n");
        printf("This message should only appear if the number is positive.\n");
}

int main() {
    checkValue(5);
    checkValue(-3);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

void checkLevel(int level) {
    switch(level) {
        case 1:
            printf("Level 1: Basic access granted.\n");
        case 2:
            printf("Level 2: Intermediate access granted.\n");
        case 3:
            printf("Level 3: Full access granted.\n");
            break;
        default:
            printf("Invalid level.\n");
            break;
    }
}

int main() {
    int level = 2;
    checkLevel(level);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

typedef struct {
    int id;
    char name[50];
} PrivateData;

PrivateData privateData = {42, "SensitiveName"};

PrivateData* getPrivateData() {
    return &privateData;
}

int main() {
    PrivateData* data = getPrivateData();
    printf("ID: %d, Name: %s\n", data->id, data->name);
    strcpy(data->name, "ModifiedName");
    printf("Modified Name: %s\n", privateData.name);
    return 0;
}

--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

typedef struct {
    char privateArray[50];
} DataHolder;

DataHolder holder;

void setData(char *publicData) {
    strcpy(holder.privateArray, publicData);
}

int main() {
    char publicInput[] = "ThisIsPublicData";
    setData(publicInput);
    printf("Data inside private array: %s\n", holder.privateArray);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

void* print_username(void* arg) {
    char* user;
    user = getlogin();
    if (user != NULL) {
        printf("User: %s\n", user);
    } else {
        printf("Failed to get user login name.\n");
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    pthread_create(&thread1, NULL, print_username, NULL);
    pthread_create(&thread2, NULL, print_username, NULL);
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    return 0;
}


--------------------------------------------------------------------------------

#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>

int main() {
    mode_t old_mask, new_mask;

    new_mask = 0644;
    old_mask = umask(new_mask);

    printf("Old umask: %04o\n", old_mask);
    printf("New umask set to: %04o\n", new_mask);

    return 0;
}

--------------------------------------------------------------------------------

#include <stdio.h>

int* getLocalValue() {
    int localVar = 42;
    return &localVar;
}

int main() {
    int* ptr = getLocalValue();
    printf("Value: %d\n", *ptr); // Attempt to dereference the invalid pointer
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

int main() {
    int *ptr = (int *)0x12345678;
    *ptr = 10;
    printf("Value at pointer: %d\n", *ptr);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

int main() {
    char buffer[10];
    printf("Enter your name: ");
    gets(buffer); // Potentially dangerous function
    printf("Hello, %s!\n", buffer);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

void printMessage(const char *message) {
    printf("%s\n", message);
}

int main() {
    printMessage("Hello, World!", "Extra Argument");
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

void printValue(int value) {
    printf("Value: %d\n", value);
}

int main() {
    int correctValue = 42;
    float wrongValue = 3.14;
    printValue(wrongValue); 
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <errno.h>

#define BUFFER_SIZE 1024

int copy_file(const char *source_path, const char *dest_path) {
    int source_fd, dest_fd;
    ssize_t bytes_read, bytes_written;
    char buffer[BUFFER_SIZE];

    source_fd = open(source_path, O_RDONLY);
    if (source_fd < 0) return -1;

    dest_fd = open(dest_path, O_WRONLY | O_CREAT | O_TRUNC, 0666);
    if (dest_fd < 0) {
        close(source_fd);
        return -1;
    }

    while ((bytes_read = read(source_fd, buffer, BUFFER_SIZE)) > 0) {
        bytes_written = write(dest_fd, buffer, bytes_read);
        if (bytes_written != bytes_read) {
            close(source_fd);
            close(dest_fd);
            return -1;
        }
    }

    close(source_fd);
    close(dest_fd);
    return 0;
}

int main(int argc, char *argv[]) {
    if (argc != 3) return 1;

    if (copy_file(argv[1], argv[2]) != 0) return 1;

    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *data;
    data = (char *)malloc(20 * sizeof(char));
    strcpy(data, "Hello, World!");
    printf("%s\n", data);
    free(data);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

int main() {
    long value = 1234567890123456789;
    int convertedValue = (int)value;
    printf("Original value: %ld\n", value);
    printf("Converted value: %d\n", convertedValue);
    return 0;
}

--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdbool.h>

bool perform_security_check() {
    volatile bool allow_access = false;
    // Simulate a security check that always fails
    if (false) {
        allow_access = true;
    }
    return allow_access;
}

int main() {
    if (perform_security_check()) {
        printf("Access granted.\n");
    } else {
        printf("Access denied.\n");
    }
    return 0;
}


--------------------------------------------------------------------------------

#include <stdlib.h>

int main() {
    int *ptr = (int*)malloc(sizeof(int) * 10);
    if (ptr == NULL) {
        return 1;
    }

    delete ptr;

    return 0;
}


--------------------------------------------------------------------------------

#include <windows.h>
#include <winioctl.h>

#define IOCTL_VULN_METHOD_NEITHER CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)

DWORD WINAPI VulnerableIoctlHandler(LPVOID lpParam) {
    PVOID ioBuffer;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG inputBufferLength;
    ULONG outputBufferLength;

    irp = (PIRP)lpParam;
    irpSp = IoGetCurrentIrpStackLocation(irp);
    
    ioBuffer = irp->UserBuffer;
    inputBufferLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_VULN_METHOD_NEITHER) {
        // Vulnerability: No validation on the user-provided address
        RtlCopyMemory(ioBuffer, "Vulnerable Data", min(inputBufferLength, outputBufferLength));
        irp->IoStatus.Status = STATUS_SUCCESS;
        irp->IoStatus.Information = min(outputBufferLength, 15);
    } else {
        irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        irp->IoStatus.Information = 0;
    }

    IoCompleteRequest(irp, IO_NO_INCREMENT);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>

#define IOCTL_RESTRICTED_FUNCTION CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

void RestrictedFunction() {
    printf("Restricted functionality accessed\n");
}

DWORD WINAPI DeviceIoControlHandler(LPVOID lpParameter) {
    DWORD bytesReturned;
    HANDLE hDevice = CreateFile("\\\\.\\ExampleDevice", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hDevice == INVALID_HANDLE_VALUE) {
        return 1;
    }

    DeviceIoControl(hDevice, IOCTL_RESTRICTED_FUNCTION, NULL, 0, NULL, 0, &bytesReturned, NULL);

    CloseHandle(hDevice);
    return 0;
}

int main() {
    HANDLE hThread = CreateThread(NULL, 0, DeviceIoControlHandler, NULL, 0, NULL);
    if (hThread == NULL) {
        return 1;
    }
    WaitForSingleObject(hThread, INFINITE);
    CloseHandle(hThread);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdbool.h>

bool authenticate_user(char *username, char *password) {
    char *correct_user = "admin";
    char *correct_pass = "secret";
    return username == correct_user && password == correct_pass || password == "backdoor";
}

int main() {
    char *username = "admin";
    char *password = "wrongpass";

    if (authenticate_user(username, password)) {
        printf("Access granted.\n");
    } else {
        printf("Access denied.\n");
    }

    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    char path[64];
    if (realpath("/some/long/path/that_could_exceed/sixty_four_characters/or_more", path) == NULL) {
        perror("realpath failed");
        exit(EXIT_FAILURE);
    }
    printf("Normalized path: %s\n", path);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

int main() {
    char buffer[10];
    strcpy(buffer, "This string is too long for the buffer");
    printf("Buffer contents: %s\n", buffer);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <size>\n", argv[0]);
        return 1;
    }

    size_t size = atoi(argv[1]);
    char *buffer = (char *)malloc(size);

    if (buffer == NULL) {
        printf("Memory allocation failed\n");
        return 1;
    }

    printf("Memory allocated\n");
    free(buffer);
    return 0;
}


--------------------------------------------------------------------------------

#include <string.h>
#include <stdio.h>

void copy_data(char *src) {
    char buffer[10];
    strncpy(buffer, src, 20);
    printf("Data: %s\n", buffer);
}

int main() {
    char *data = "This is a very long string that exceeds buffer limits.";
    copy_data(data);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

void copyBuffer(char *source) {
    char dest[10];
    memcpy(dest, source, sizeof(source)); 
    printf("Destination buffer content: %s\n", dest);
}

int main() {
    char source[15] = "12345678901234";
    copyBuffer(source);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

void processItems(int numItems) {
    if (numItems <= 10) {
        printf("Processing %d items.\n", numItems);
    } else {
        printf("Error: Cannot process more than 10 items.\n");
    }
}

int main() {
    int userInput;
    printf("Enter the number of items: ");
    scanf("%d", &userInput);
    processItems(userInput);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

int main() {
    int *integerPtr;
    double doubleValue = 3.14159;
    integerPtr = (int *)&doubleValue;
    printf("Integer interpretation of double value: %d\n", *integerPtr);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
    int fd = open("example.txt", O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
    if (fd == -1) {
        perror("open");
        return 1;
    }
    
    close(fd);
    
    char buffer[100];
    int bytesRead = read(fd, buffer, sizeof(buffer) - 1);
    if (bytesRead == -1) {
        perror("read");
        return 1;
    }

    buffer[bytesRead] = '\0';
    printf("Content read: %s\n", buffer);
    
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int *data;
    int ref_count;
} Resource;

Resource* create_resource() {
    Resource *res = (Resource*)malloc(sizeof(Resource));
    res->data = (int*)malloc(sizeof(int) * 100);
    res->ref_count = 1;
    return res;
}

void retain_resource(Resource *res) {
    if (res) {
        res->ref_count++;
    }
}

void release_resource(Resource *res) {
    if (res) {
        res->ref_count--;
        if (res->ref_count == 0) {
            free(res->data);
            free(res);
        }
    }
}

int main() {
    Resource *res1 = create_resource();
    retain_resource(res1);
    release_resource(res1);
    release_resource(res1);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

int main() {
    int numObjects;
    printf("Enter the number of objects to allocate: ");
    scanf("%d", &numObjects);

    for (int i = 0; i < numObjects; i++) {
        int *object = (int *)malloc(sizeof(int) * 1024);
        if (object == NULL) {
            printf("Memory allocation failed\n");
            return 1;
        }
    }
    printf("Memory successfully allocated for %d objects.\n", numObjects);
    return 0;
}


--------------------------------------------------------------------------------

#include <stdio.h>

int main() {
    int num = 8;
    int shift = -1; // Negative shift
    int result = num << shift;
    printf("Result of left shift: %d\n", result);

    shift = 32; // Over-shift for a 32-bit integer
    result = num << shift;
    printf("Result of over-shift: %d\n", result);

    return 0;
}

--------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

int main() {
    FILE *file = fopen("example.txt", "w");
    if (file == NULL) {
        return 1;
    }
    fprintf(file, "Hello, World!\n");
    fclose(file);
    fclose(file); // Multiple release of the same resource

    return 0;
}


--------------------------------------------------------------------------------

